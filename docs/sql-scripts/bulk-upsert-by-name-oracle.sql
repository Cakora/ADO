/*
Bulk upsert from XML input by unique NAME (Oracle).

Input XML format:
<Items>
  <Item SourceId="1" Name="Alice" />
  <Item SourceId="2" Name="Bob" />
</Items>

Behavior:
- For each Item, match destination row by NAME (Oracle folds unquoted identifiers to uppercase; string comparisons depend on NLS/collation).
- If NAME exists: reuse existing ID.
- If NAME is new: insert and generate ID.
- Marks destination row as imported (IS_IMPORTED = 1).
- Returns a SYS_REFCURSOR mapping SOURCE_ID -> DESTINATION_ID with SUCCESS/INSERTED flags.
- Processes distinct names in batches of 500 to keep DML predictable on large payloads.
*/

-- Demo table (adjust schema/table/columns as needed)
BEGIN
    EXECUTE IMMEDIATE '
        CREATE TABLE ITEM_CATALOG
        (
            ID          NUMBER GENERATED BY DEFAULT AS IDENTITY PRIMARY KEY,
            NAME        VARCHAR2(200) NOT NULL,
            IS_IMPORTED NUMBER(1) DEFAULT 0 NOT NULL,
            CREATED_AT  TIMESTAMP(3) DEFAULT SYSTIMESTAMP NOT NULL
        )';
EXCEPTION
    WHEN OTHERS THEN
        IF SQLCODE != -955 THEN -- ORA-00955: name is already used
            RAISE;
        END IF;
END;
/

BEGIN
    EXECUTE IMMEDIATE 'CREATE UNIQUE INDEX UX_ITEM_CATALOG_NAME ON ITEM_CATALOG(NAME)';
EXCEPTION
    WHEN OTHERS THEN
        IF SQLCODE != -955 THEN
            RAISE;
        END IF;
END;
/

CREATE OR REPLACE PROCEDURE UPSERT_ITEM_CATALOG_FROM_XML
(
    P_ITEMS_XML IN XMLTYPE,
    P_RESULT    OUT SYS_REFCURSOR
)
AS
    V_START_RN NUMBER := 1;
    V_TOTAL    NUMBER := 0;
BEGIN
    -- Parse input XML into rows.
    -- NAME is trimmed; empty string becomes NULL in Oracle.
    -- Upsert by NAME without MERGE (batched):
    -- 1) insert missing names in batches of 500
    -- 2) update existing matches to set IS_IMPORTED = 1
    SELECT COUNT(1)
    INTO V_TOTAL
    FROM
    (
        SELECT DISTINCT NULLIF(TRIM(X.NAME), '') AS NAME
        FROM XMLTABLE(
            '/Items/Item'
            PASSING P_ITEMS_XML
            COLUMNS NAME VARCHAR2(200) PATH '@Name'
        ) X
        WHERE NULLIF(TRIM(X.NAME), '') IS NOT NULL
    );

    WHILE V_START_RN <= V_TOTAL LOOP
        -- Insert missing names for this batch.
        INSERT INTO ITEM_CATALOG (NAME, IS_IMPORTED)
        SELECT B.NAME, 1
        FROM
        (
            SELECT NAME
            FROM
            (
                SELECT
                    D.NAME,
                    ROW_NUMBER() OVER (ORDER BY D.NAME) RN
                FROM
                (
                    SELECT DISTINCT NULLIF(TRIM(X.NAME), '') AS NAME
                    FROM XMLTABLE(
                        '/Items/Item'
                        PASSING P_ITEMS_XML
                        COLUMNS NAME VARCHAR2(200) PATH '@Name'
                    ) X
                    WHERE NULLIF(TRIM(X.NAME), '') IS NOT NULL
                ) D
            )
            WHERE RN BETWEEN V_START_RN AND (V_START_RN + 499)
        ) B
        WHERE NOT EXISTS (SELECT 1 FROM ITEM_CATALOG T WHERE T.NAME = B.NAME);

        -- Update existing matches for this batch (inserted rows already set IS_IMPORTED = 1).
        UPDATE ITEM_CATALOG T
            SET T.IS_IMPORTED = 1
        WHERE EXISTS
        (
            SELECT 1
            FROM
            (
                SELECT NAME
                FROM
                (
                    SELECT
                        D.NAME,
                        ROW_NUMBER() OVER (ORDER BY D.NAME) RN
                    FROM
                    (
                        SELECT DISTINCT NULLIF(TRIM(X.NAME), '') AS NAME
                        FROM XMLTABLE(
                            '/Items/Item'
                            PASSING P_ITEMS_XML
                            COLUMNS NAME VARCHAR2(200) PATH '@Name'
                        ) X
                        WHERE NULLIF(TRIM(X.NAME), '') IS NOT NULL
                    ) D
                )
                WHERE RN BETWEEN V_START_RN AND (V_START_RN + 499)
            ) B
            WHERE B.NAME = T.NAME
        );

        V_START_RN := V_START_RN + 500;
    END LOOP;

    -- Return mapping list: one row per input item.
    OPEN P_RESULT FOR
        WITH INPUT_ROWS AS
        (
            SELECT
                X.SOURCE_ID,
                NULLIF(TRIM(X.NAME), '') AS NAME
            FROM XMLTABLE(
                '/Items/Item'
                PASSING P_ITEMS_XML
                COLUMNS
                    SOURCE_ID NUMBER        PATH '@SourceId',
                    NAME      VARCHAR2(200) PATH '@Name'
            ) X
        ),
        DISTINCT_NAMES AS
        (
            SELECT DISTINCT NAME
            FROM INPUT_ROWS
            WHERE NAME IS NOT NULL
        ),
        EXISTING_NAMES AS
        (
            SELECT T.NAME
            FROM ITEM_CATALOG T
            JOIN DISTINCT_NAMES D ON D.NAME = T.NAME
        )
        SELECT
            I.SOURCE_ID,
            T.ID AS DESTINATION_ID,
            CASE WHEN I.NAME IS NOT NULL AND E.NAME IS NULL THEN 1 ELSE 0 END AS INSERTED,
            CASE WHEN I.NAME IS NOT NULL THEN 1 ELSE 0 END AS SUCCESS,
            CASE WHEN I.NAME IS NULL THEN 'Name is required' ELSE NULL END AS ERROR_MESSAGE
        FROM INPUT_ROWS I
        LEFT JOIN ITEM_CATALOG T ON T.NAME = I.NAME
        LEFT JOIN EXISTING_NAMES E ON E.NAME = I.NAME
        ORDER BY I.SOURCE_ID;
END;
/
